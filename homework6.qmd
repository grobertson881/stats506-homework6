---
title: "Homework 6"
format:
  html:
    embed-resources: true
editor: visual
---

Link to Github repository: https://github.com/grobertson881/stats506-homework6

**Problem 1**

```{r}
library(Rcpp)

cppFunction("
double C_moment(NumericVector v, int k) {
  double mean = 0;
  for (int i = 0; i < v.length(); ++i){
     mean += v[i];
  }
  mean = mean / v.length();
  
  double total = 0.0;
  for (int i = 0; i < v.length(); ++i) {
    total += pow(v[i] - mean, k);
  }

  return (total / v.length());
}")

# Test it works using e1071
library(e1071)
set.seed(1)
x <- rnorm(20)

C_moment(x, 3)
moment(x, order = 3, center = TRUE)
```

**Problem 2**

*Part A*

```{r}
source("waldCI.R")

setClass("bootstrapWaldCI",
  contains = "waldCI",
  slots = c(
    data = "data.frame",
    func = "function",
    reps = "numeric",
    compute = "character"
  )
)

setValidity("bootstrapWaldCI", function(object) {
  if (!(object@compute %in% c("serial", "parallel"))) {
    stop("compute must be 'serial' or 'parallel'")
  }
  if (object@reps <= 0) {
    stop("reps must be positive")
  }
  TRUE
})

##' Create bootstrapWaldCI object
##' @export
makeBootstrapCI <- function(func, data, reps = 1000, level = 0.95, compute = "serial") {
  stopifnot(is.function(func))
  stopifnot(is.data.frame(data))

  n <- nrow(data)
  if (compute == "serial") {
    boots <- numeric(reps)
    for (i in seq_len(reps)) {
      idx <- sample.int(n, replace = TRUE)
      boots[i] <- func(data[idx, , drop = FALSE])
    }
  } else {
    cores <- max(1, parallel::detectCores() - 1)
    boots <- unlist(
      parallel::mclapply(
        seq_len(reps),
        function(i) {
          idx <- sample.int(n, replace = TRUE)
          func(data[idx, , drop = FALSE])
        },
        mc.cores = cores
      )
    )
  }

  mean_hat  <- mean(boots)
  sterr_hat <- sd(boots)

  new("bootstrapWaldCI",
      level = level,
      mean = mean_hat,
      sterr = sterr_hat,
      data = data,
      func = func,
      reps = reps,
      compute = compute)
}

setGeneric("rebootstrap", function(object) {
  standardGeneric("rebootstrap")
})

setMethod("rebootstrap", "bootstrapWaldCI", function(object) {
  data <- object@data
  func <- object@func
  reps <- object@reps
  compute <- object@compute
  n <- nrow(data)

  if (compute == "serial") {
    boots <- numeric(reps)
    for (i in seq_len(reps)) {
      idx <- sample.int(n, replace = TRUE)
      boots[i] <- func(data[idx, , drop = FALSE])
    }
  } else {
    cores <- max(1, parallel::detectCores() - 1)
    boots <- unlist(
      parallel::mclapply(
        seq_len(reps),
        function(i) {
          idx <- sample.int(n, replace = TRUE)
          func(data[idx, , drop = FALSE])
        },
        mc.cores = cores
      )
    )
  }

  mean_hat  <- mean(boots)
  sterr_hat <- sd(boots)

  new("bootstrapWaldCI",
      level = object@level,
      mean = mean_hat,
      sterr = sterr_hat,
      data = data,
      func = func,
      reps = reps,
      compute = compute)
})
```

*Part B*

```{r}
# show it works from homework
ci1 <- makeBootstrapCI(function(x) mean(x$y),
                       ggplot2::diamonds,
                       reps = 1000)
ci1
rebootstrap(ci1)

# compare compute methods
ci1_serial_time <- system.time(
    makeBootstrapCI(function(x) mean(x$y), ggplot2::diamonds,reps = 1000,compute = "serial")
)

ci1_parallel_time <- system.time(
    makeBootstrapCI(function(x) mean(x$y), ggplot2::diamonds,reps = 1000,compute = "parallel")
)

ci1_serial_time
ci1_parallel_time
```

In parallel, the elapsed time decreases by about half because it is running multiple cores at the same time. It is a large dataset, so the elapsed time is still a few seconds in both cases. 

*Part C*

```{r}
dispCoef <- function(data) {
  fit <- lm(mpg ~ cyl + disp + wt, data = data)
  coef(fit)[["disp"]]
}

# show it works from homework
ci2 <- makeBootstrapCI(dispCoef,
                       mtcars,
                       reps = 1000)
ci2
rebootstrap(ci2)

# compare compute methods
ci2_serial_time <- system.time(
    makeBootstrapCI(dispCoef, mtcars,reps = 1000,compute = "serial")
)

ci2_parallel_time <- system.time(
    makeBootstrapCI(dispCoef, mtcars,reps = 1000,compute = "parallel")
)

ci2_serial_time
ci2_parallel_time

```

Again, the parallel time decreases by about half. Overall the times are both much smaller because the mtcars dataset is much smaller than the dataset from part B. 

**Problem 3**

*Part A*

```{r}


```

*Part B*

```{r}


```

**Problem 4**

```{r}
library(data.table)
tennis <- fread("https://raw.githubusercontent.com/JeffSackmann/tennis_atp/refs/heads/master/atp_matches_2019.csv")
```

*Part A*

```{r}
tennis[, tourney_year := floor(tourney_date / 10000)]
tennis[tourney_year == 2019, uniqueN(tourney_id)]
```

There were 125 tournaments played in 2019.

*Part B*

```{r}
winners <- tennis[round == "F", .N, by = winner_name]

winners[N > 1, .N]
winners[, max(N)]
winners[N == max(N)]
```

There are 12 players who have won more than 1 tournament. Novak Djokovic and Dominic Thiem are tied for the highest number of tournament wins with 5. 

*Part C*

```{r}
library(broom)  

tennis <- tennis[!is.na(w_ace) & !is.na(l_ace)]
tennis[, win_more := w_ace > l_ace]          # create logical column
n_win_more <- tennis[, sum(win_more)]        # number of matches winner had more aces
n_total <- nrow(tennis)                      # total matches

prop.test(n_win_more, n_total, p = 0.5)
```

There is evidence that winners have more aces because the p-value is so much smaller than 0.05.

*Part D*

```{r}
wins <- tennis[, .N, by = winner_name]
setnames(wins, c("winner_name", "wins"))

matches_winner <- tennis[, .N, by = winner_name]
matches_loser  <- tennis[, .N, by = loser_name]
setnames(matches_winner, c("player", "matches_won"))
setnames(matches_loser, c("player", "matches_lost"))

matches <- merge(matches_winner, matches_loser, by = "player", all = TRUE)
matches[is.na(matches)] <- 0
matches[, total_matches := matches_won + matches_lost]

matches[, win_rate := matches_won / total_matches]

matches_filtered <- matches[total_matches >= 5]
matches_filtered[order(-win_rate)]
```

The player with the highest win rate is Rafael Nadal with 86.96% of his games being wins. 

